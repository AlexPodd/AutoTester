package org.example.Exploit;

import java.io.*;
import java.util.concurrent.TimeUnit;

public class Exploit implements Serializable {
    protected final int CVSS;
    protected StringBuilder Report;
    protected boolean IsNeed;
    protected boolean IsWork;
    protected final String name;
    protected final String repair;
    protected String pathToExploit;
    protected String pathToCode;
    protected final String outputPath = "src/main/java/org/example/CodeExploit";
    public Exploit(String name, String CVSS, String repair, String pathToCode) {
        this.name = name;
        this.CVSS = Integer.parseInt(CVSS);
        this.repair = repair;
        this.pathToCode = pathToCode;
        pathToExploit = outputPath+"/"+name+"Compile";
        IsWork = false;
        IsNeed = true;
        Report = new StringBuilder();
    }

    public String getName() {
        return name;
    }

    public boolean isWork() {
        return Report.toString().contains("uid=0");
    }

    public void setWork(boolean work) {
        IsWork = work;
    }

    public boolean isNeed() {
        return IsNeed;
    }

    public void setNeed(boolean need) {
        IsNeed = need;
    }

    public int getCVSS() {
        return CVSS;
    }

    public void run(){
        try {
            compile();
            String[] command = {"/bin/sh", "-c", pathToExploit + " ; id ; exit"};

            ProcessBuilder builder = new ProcessBuilder(command);
            Process process = builder.start();

            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                Report.append(line).append("\n");

            }

            // Ограничение на время выполнения в 30 секунд
            boolean finished = process.waitFor(30, TimeUnit.SECONDS);

            if (!finished) {
                process.destroy();
                Report.append("Процесс был принудительно завершён после 30 секунд.\n");
            } else {
                int exitCode = process.exitValue();
                Report.append("Процесс завершился с кодом: ").append(exitCode).append("\n");
            }

        } catch (Exception e) {
            Report.append("Ошибка при выполнении: ").append(e.getMessage()).append("\n");
        }
    }

    public String getRepair() {
        return repair;
    }

    //Return test-result
    public void Result() throws IOException {

    }

    public String getPathToExploit() {
        return pathToExploit;
    }

    public String getReport(){
        return Report.toString();
    }
    public StringBuilder getRep(){
        return Report;
    }

    protected void compile() throws IOException {
        //String compileCommand = String.format("gcc %s -o %s", name, outputFile.getAbsolutePath());

        String compileCommand = "gcc -x c " + pathToCode + " -o " +   pathToExploit;
        Process process = Runtime.getRuntime().exec(compileCommand);

        try (BufferedReader stdError = new BufferedReader(new InputStreamReader(process.getErrorStream()));
             BufferedReader stdOutput = new BufferedReader(new InputStreamReader(process.getInputStream()))) {

            if (!process.waitFor(5, TimeUnit.SECONDS)) {
                process.destroy();
                Report.append("Compilation timed out.");
            }

            if (process.exitValue() != 0) {
                StringBuilder errorOutput = new StringBuilder();
                String line;
                while ((line = stdError.readLine()) != null) {
                    errorOutput.append(line).append("\n");
                }
                Report.append("Compilation failed:\n").append(errorOutput.toString());
            }
        } catch (InterruptedException e) {
            process.destroy();
            Report.append("Compilation was interrupted");
        }
    }

    public boolean SaveExploit(){
        String command = "cp -p " + pathToCode + " " + outputPath+"/"+name;
        pathToCode = outputPath+"/"+name;
        try {
            // Запускаем команду через Runtime
            Process process = Runtime.getRuntime().exec(command);

            // Ожидаем завершения команды
            int exitCode = process.waitFor();

            // Проверяем, успешна ли команда
            if (exitCode == 0) {
                return true;
            } else {
                return false;
            }
        } catch (IOException | InterruptedException e) {
            return false;
        }
    }

    public String getPathToCode() {
        return pathToCode;
    }
}
