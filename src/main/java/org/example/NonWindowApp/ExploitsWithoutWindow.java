package org.example.NonWindowApp;

import org.example.Exploit.Exploit;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartUtils;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.statistics.HistogramDataset;
import org.jfree.data.statistics.HistogramType;

import java.io.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

public class ExploitsWithoutWindow{

    private ArrayList<Exploit> exploits;



    private String formattedDateTime;
    private final String Config = "src/main/resources/InfoExploit.txt";
    private final String PathToSaveRes = "Result";
    private int progress;
    private final int totalExploits;
    protected final String outputPath = "src/main/java/org/example/CodeExploit";
    private String ResultPath;
    private volatile boolean running;
    private boolean done = false;
    public ExploitsWithoutWindow(){
        progress = 0;
        exploits = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(Config))) {
            String line;
            while ((line = reader.readLine()) != null) {
                exploits.add(LineToExploit(line));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        totalExploits = exploits.size();

    }
    private Exploit LineToExploit(String line){
        String[] word = line.split(" ");

        return new Exploit(word[0], word[1], word[2], word[3]);
    }

    public Void run() throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();

        running = true;

        Thread progressBarThread = new Thread(this::runProgressBar);
        progressBarThread.start();
        for (Exploit cve : exploits) {
            if (cve.isNeed()) {
                // Ограничиваем выполнение эксплоита 10 секундами
                Future<?> future = executor.submit(() -> {
                    cve.run();
                    try {
                        cve.Result();
                    } catch (IOException e) {
                        cve.getRep().append("TimeOut exception ").append(e);
                    }
                });

                try {
                    future.get(15, TimeUnit.SECONDS);
                } catch (TimeoutException e) {
                    future.cancel(true);
                    cve.getRep().append("The exploit execution time exceeded 15 seconds!");
                } catch (ExecutionException | InterruptedException e) {
                    e.printStackTrace();
                }
                progress++;

            }
        }

        executor.shutdown();
        done = true;
        running = false;
        // Форматируем текущую дату и время
        LocalDateTime currentDateTime = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        formattedDateTime = currentDateTime.format(formatter).replace(":", "-");

        // Генерируем отчёт и гистограмму
        GenerateReport();
        createHistogram();

        return null;
    }

    public void GenerateReport(){
        String filename = "Report-" + formattedDateTime + ".txt";
        BufferedWriter writer = null;
        try {
            File file = new File(PathToSaveRes,filename);
            ResultPath = file.getAbsolutePath();
            FileWriter fileWriter = new FileWriter(file);
            writer = new BufferedWriter(fileWriter);
            writer.write(formattedDateTime);
            writer.newLine();
            for (Exploit cve : exploits) {
                if(cve.isNeed()){
                    writer.write(cve.getName());
                    writer.newLine();
                    writer.write(cve.getReport());
                    writer.newLine();
                    if(cve.isWork()){
                        writer.write("The exploit worked");
                        writer.newLine();
                        writer.write(cve.getRepair());
                    }
                    else{
                        writer.write("Exploit doesn't work");
                    }
                    writer.newLine();
                }
                else{
                    writer.write(cve.getName()+" (Disabled)");
                }
                writer.newLine();
            }
            writer.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (writer != null) {
                    writer.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    private void createHistogram() {
        HistogramDataset dataset = new HistogramDataset();
        dataset.setType(HistogramType.FREQUENCY);
        int numberOfBins = 10; // количество столбцов в гистограмме

        // Получение данных CVSS из списка exploits


        double[] cvss = new double[exploits.size()];
        for (int i = 0; i < exploits.size(); i++) {
            if(exploits.get(i).isWork()){
                cvss[i] = exploits.get(i).getCVSS();
            }
        }

        // Добавление серии данных
        dataset.addSeries("CVSS", cvss, numberOfBins, 1.0, 10.0);

        // Создание гистограммы
        JFreeChart histogram = ChartFactory.createHistogram(
                "Exploits that worked",
                "CVSS Score",
                "Number of Vulnerabilities",
                dataset,
                PlotOrientation.VERTICAL,
                true,   // показать легенду
                true,   // показывать tooltips
                false   // не использовать URL генерацию
        );

        // Сохранение гистограммы в файл
        int width = 800;
        int height = 600;
        String filename = "histogram-"+formattedDateTime+".png";
        File histogramFile = new File(PathToSaveRes, filename);
        try {
            ChartUtils.saveChartAsPNG(histogramFile, histogram, width, height);
        } catch (IOException e) {
            //    System.err.println("Error saving the histogram image.");
            e.printStackTrace();
        }
        //  System.out.println("Histogram saved as histogram.png");
    }

    private void runProgressBar() {
        int barWidth = 50; // Ширина прогресс-бара

        while (!done) { // Пока основной процесс не завершён
            int completed = (int) ((double) progress / totalExploits * barWidth);

            StringBuilder progressBar = new StringBuilder("[");
            for (int i = 0; i < completed; i++) {
                progressBar.append("=");
            }
            for (int i = completed; i < barWidth; i++) {
                progressBar.append(" ");
            }
            progressBar.append("] ");

            int percent = (int) ((double) progress / totalExploits * 100);
            System.out.print("\r" + progressBar.toString() + percent + "%");

            try {
                Thread.sleep(100); // Обновляем прогресс-бар каждые 100 миллисекунд
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        // После завершения основной работы выводим 100% и завершаем прогресс-бар
        System.out.print("\r[==================================================] 100%");
    }


}
