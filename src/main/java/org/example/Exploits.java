package org.example;

import org.example.Exploit.Exploit;
import org.example.Exploit.ExploitExecutable;
import org.example.Exploit.ExploitPy;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartUtils;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.statistics.HistogramDataset;
import org.jfree.data.statistics.HistogramType;

import javax.swing.*;
import java.awt.*;
import java.io.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

public class Exploits extends SwingWorker<Void, String> {

    private ArrayList<Exploit> exploits;



    private String formattedDateTime;
    private final String Config = "src/main/resources/InfoExploit.txt";
    private final String PathToSaveRes = "Result";
    private int progress;
    protected final String outputPath = "src/main/java/org/example/CodeExploit";
    private String ResultPath;
    private MainFrame mainframe;
    public Exploits(MainFrame frame){
        this.mainframe = frame;
        progress = 0;
        exploits = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(Config))) {
            String line;
            while ((line = reader.readLine()) != null) {
                exploits.add(LineToExploit(line));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }


    }
    private Exploit LineToExploit(String line){
        String[] word = line.split(" ");

        return new Exploit(word[0], word[1], word[2], word[3]);
    }

    @Override
    protected Void doInBackground() throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        for (Exploit cve : exploits) {
            if (cve.isNeed()) {
                // Ограничиваем выполнение эксплоита 10 секундами
                Future<?> future = executor.submit(() -> {
                    cve.run();
                    try {
                        cve.Result();
                    } catch (IOException e) {
                        cve.getRep().append("TimeOut exception ").append(e);
                    }
                });

                try {
                    future.get(15, TimeUnit.SECONDS);
                } catch (TimeoutException e) {
                    future.cancel(true);
                    cve.getRep().append("The exploit execution time exceeded 15 seconds!");
                } catch (ExecutionException | InterruptedException e) {
                    e.printStackTrace();
                }
                publish(String.valueOf(progress));
                progress++;
            }
        }

        executor.shutdown();

        // Форматируем текущую дату и время
        LocalDateTime currentDateTime = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        formattedDateTime = currentDateTime.format(formatter).replace(":", "-");

        // Генерируем отчёт и гистограмму
        GenerateReport();
        createHistogram();

        return null;
    }

    public void AddExploit(String name, String CVSS, String patch, String programPath) {
        String extension = programPath.substring(programPath.indexOf(".") + 1);
        Exploit exploit;
        if (!extension.equals("py")) {
            exploit = new ExploitPy(name, CVSS, patch, programPath);
        }
        else {
            exploit = new ExploitExecutable(name, CVSS, patch, programPath);
        }
        exploit.SaveExploit();
        AddExploit(exploit);
        mainframe.ShowInfoMessage("Добавлен новый эксплоит. Перезапустите приложение для его отображения");
    }

    private void AddExploit(Exploit exploit){
        String save = exploit.getName()+" "+exploit.getCVSS()+" "+exploit.getRepair()+" "+exploit.getPathToCode();

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(Config, true))) {
            writer.write(save);
            writer.newLine();
        } catch (IOException e) {
            mainframe.ShowErrorMessage("Cant save exploit:\n" + e.toString());
        }
    }

    public ArrayList<Exploit> getExploits() {
        return exploits;
    }

    public void GenerateReport(){
        String filename = "Report-" + formattedDateTime + ".txt";
        BufferedWriter writer = null;
        try {
            File file = new File(PathToSaveRes,filename);
            ResultPath = file.getAbsolutePath();
                FileWriter fileWriter = new FileWriter(file);
                writer = new BufferedWriter(fileWriter);
                writer.write(formattedDateTime);
                writer.newLine();
                for (Exploit cve : exploits) {
                    if(cve.isNeed()){
                        writer.write(cve.getName());
                        writer.newLine();
                        writer.write(cve.getReport());
                        writer.newLine();
                        if(cve.isWork()){
                            writer.write("The exploit worked");
                            writer.newLine();
                            writer.write(cve.getRepair());
                        }
                        else{
                            writer.write("Exploit doesn't work");
                        }
                        writer.newLine();
                    }
                    else{
                        writer.write(cve.getName()+" (Disabled)");
                }
                    writer.newLine();
            }
            writer.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (writer != null) {
                    writer.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private void createHistogram() {
        HistogramDataset dataset = new HistogramDataset();
        dataset.setType(HistogramType.FREQUENCY);
        int numberOfBins = 10; // количество столбцов в гистограмме

        // Получение данных CVSS из списка exploits


        double[] cvss = new double[exploits.size()];
        for (int i = 0; i < exploits.size(); i++) {
            if(exploits.get(i).isWork()){
                cvss[i] = exploits.get(i).getCVSS();
            }
        }

        // Добавление серии данных
        dataset.addSeries("CVSS", cvss, numberOfBins, 1.0, 10.0);

        // Создание гистограммы
        JFreeChart histogram = ChartFactory.createHistogram(
                "Exploits that worked",
                "CVSS Score",
                "Number of Vulnerabilities",
                dataset,
                PlotOrientation.VERTICAL,
                true,   // показать легенду
                true,   // показывать tooltips
                false   // не использовать URL генерацию
        );

        // Сохранение гистограммы в файл
        int width = 800;
        int height = 600;
        String filename = "histogram-"+formattedDateTime+".png";
        File histogramFile = new File(PathToSaveRes, filename);
        try {
            ChartUtils.saveChartAsPNG(histogramFile, histogram, width, height);
        } catch (IOException e) {
        //    System.err.println("Error saving the histogram image.");
            e.printStackTrace();
        }
      //  System.out.println("Histogram saved as histogram.png");
    }

    @Override
    public Void resultNow() {
        return super.resultNow();
    }

    @Override
    public Throwable exceptionNow() {
        return super.exceptionNow();
    }

    @Override
    public State state() {
        return super.state();
    }

    @Override
    protected void process(List<String> chunks) {
        for (String text : chunks) {
            //process.append(text+"\n");
            mainframe.UpdateProgressBar(Integer.parseInt(text),exploits.size());
        }
    }

    @Override
    protected void done() {
        //process.append("Все эксплоиты протестированы, результат работы программы сохранен в виде отчета");
        mainframe.IsDone();
        mainframe.ShowInfoMessage("Эксплоиты были протестированны, отчет сохранен по пути: "+ResultPath);
        System.exit(0);
    }
}
